// +build ignore

/*
Copyright 2017 The Nuclio Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Generate errors.go from constants in net/http
package main

import (
	"flag"
	"go/importer"
	"log"
	"os"
	"regexp"
	"sort"
	"strings"
	"text/template"
)

const (
	statusPrefix = "Status"

	codeTemplateText = `// Automatically generated by gen_errors.go

/*
Copyright 2017 The Nuclio Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package nuclio

import (
	"errors"
	"fmt"
	"net/http"
)

// WithStatusCode is an error with status code
type WithStatusCode interface {
	StatusCode() int
}

// ErrorWithStatusCode implements both error and WithStatusCode
type ErrorWithStatusCode struct {
	error
	statusCode int
}

// GetError returns the underlying error
func (e *ErrorWithStatusCode) GetError() error {
	return e.error
}

// StatusCode returns the status code
func (e *ErrorWithStatusCode) StatusCode() int {
	return e.statusCode
}

// Error returns the error message
func (e ErrorWithStatusCode) Error() string {
	if e.error != nil {
		return e.error.Error()
	}

	message, ok := defaultMessages[e.statusCode]
	if !ok {
		message = fmt.Sprintf("Unknown error: %d", e.statusCode)
	}

	return message
}

{{range .}}
// {{. | StatusToError}} is a {{.}} Error
var {{. | StatusToError}} = ErrorWithStatusCode{statusCode: http.{{.}}}

// New{{. | StatusToError}} returns a new {{. | StatusToError}} with custom error message
func New{{. | StatusToError}}(message string) error {
	return &ErrorWithStatusCode{
		error: errors.New(message),
		statusCode: http.{{.}},
	}
}

// Wrap{{. | StatusToError}} returns a new {{. | StatusToError}}, wrapping an existing error
func Wrap{{. | StatusToError}}(err error) error {
	return &ErrorWithStatusCode{
		error: err,
		statusCode: http.{{.}},
	}
}
{{end}}

var defaultMessages = map[int]string{
{{- range .}}
	http.{{.}}: "{{. | HumanStatus}}",
{{- end}}
}
`
)

var (
	// Add space between camel case
	humanRe = regexp.MustCompile("([a-z])([A-Z])")
)

// StatusToError convert http status name to error name
// (e.g. "StatusAccepted" -> "ErrAccepted")
func StatusToError(status string) string {
	return "Err" + status[len(statusPrefix):]
}

// HumanStatus returns human formed status
// (e.g. "StatusTooManyRequests" -> "Too Many Requests")
func HumanStatus(status string) string {
	return humanRe.ReplaceAllString(status[len(statusPrefix):], "$1 $2")
}

func main() {
	flag.Parse() // Support -h, --help

	pkg, err := importer.Default().Import("net/http")
	if err != nil {
		log.Fatal(err)
	}

	var names []string
	for _, name := range pkg.Scope().Names() {
		if !strings.HasPrefix(name, statusPrefix) || name == "StatusOK" {
			continue
		}

		obj := pkg.Scope().Lookup(name)
		if obj.Type().String() != "untyped int" {
			continue
		}

		names = append(names, name)
	}
	sort.Strings(names)

	funcMap := template.FuncMap{
		"StatusToError": StatusToError,
		"HumanStatus":   HumanStatus,
	}
	codeTemplate, err := template.New("").Funcs(funcMap).Parse(codeTemplateText)
	if err != nil {
		log.Fatal(err)
	}

	out, err := os.Create("errors.go")
	if err != nil {
		log.Fatal(err)
	}

	if err := codeTemplate.Execute(out, names); err != nil {
		log.Fatal(err)
	}
}
